import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../data/repositories/order_repository.dart';
import '../../../data/models/models.dart';
import 'order_event.dart';
import 'order_state.dart';

class OrderBloc extends Bloc<OrderEvent, OrderState> {
  final OrderRepository _orderRepository;

  OrderBloc({
    required OrderRepository orderRepository,
  })  : _orderRepository = orderRepository,
        super(const OrderInitial()) {
    on<CreateOrder>(_onCreateOrder);
    on<LoadOrder>(_onLoadOrder);
    on<LoadUserOrders>(_onLoadUserOrders);
    on<CancelOrder>(_onCancelOrder);
    on<RefreshOrder>(_onRefreshOrder);
  }

  Future<void> _onCreateOrder(
    CreateOrder event,
    Emitter<OrderState> emit,
  ) async {
    emit(const OrderCreating());

    // Calculate order totals
    final subtotal = event.items.fold(0.0, (sum, item) => sum + item.totalPrice);
    final deliveryFee = event.restaurant.deliveryFee;
    final tax = subtotal * 0.08; // 8% tax
    final total = subtotal + deliveryFee + tax;

    final order = Order(
      id: '', // Will be generated by repository
      restaurant: event.restaurant,
      items: event.items,
      subtotal: subtotal,
      deliveryFee: deliveryFee,
      tax: tax,
      total: total,
      status: OrderStatus.pending,
      paymentMethod: event.paymentMethod,
      deliveryAddress: event.deliveryAddress,
      specialInstructions: event.specialInstructions,
      orderTime: DateTime.now(),
    );

    final result = await _orderRepository.createOrder(order);

    result.fold(
      (failure) => emit(OrderError(failure)),
      (createdOrder) => emit(OrderCreated(createdOrder)),
    );
  }

  Future<void> _onLoadOrder(
    LoadOrder event,
    Emitter<OrderState> emit,
  ) async {
    emit(const OrderLoading());

    final result = await _orderRepository.getOrderById(event.orderId);

    result.fold(
      (failure) => emit(OrderError(failure)),
      (order) => emit(OrderLoaded(order)),
    );
  }

  Future<void> _onLoadUserOrders(
    LoadUserOrders event,
    Emitter<OrderState> emit,
  ) async {
    emit(const OrderLoading());

    final result = await _orderRepository.getUserOrders();

    result.fold(
      (failure) => emit(OrderError(failure)),
      (orders) => emit(OrdersLoaded(orders)),
    );
  }

  Future<void> _onCancelOrder(
    CancelOrder event,
    Emitter<OrderState> emit,
  ) async {
    final result = await _orderRepository.cancelOrder(event.orderId);

    result.fold(
      (failure) => emit(OrderError(failure)),
      (_) => emit(OrderCancelled(event.orderId)),
    );
  }

  Future<void> _onRefreshOrder(
    RefreshOrder event,
    Emitter<OrderState> emit,
  ) async {
    add(LoadOrder(event.orderId));
  }
}